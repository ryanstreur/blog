---
title: "Pros and Cons of Semantic Versioning"
date: 2019-06-26T16:14:58-07:00
draft: true
---

Broken code sucks, especially when you didn't even write it. In the landscape of methods developers use to stop breaking each-other's code so much, semantic versioning stands out for its simplicity. If you haven't heard of semantic versioning (semver, for short), you can find the specification [here](https://semver.org/). For the benefit of readers who hate to click on links, here is their summary of the spec:

> Given a version number MAJOR.MINOR.PATCH, increment the:
>
> 1. MAJOR version when you make incompatible API changes,
> 2. MINOR version when you add functionality in a backwards-compatible manner, and
> 3. PATCH version when you make backwards-compatible bug fixes.
> 
> Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

That's it. Semantic versioning comes down to three useful numbers.

## Annotated bibliography

https://www.jvandemo.com/a-simple-guide-to-semantic-versioning/
https://surfingthe.cloud/semantic-versioning-anti-pattern/
https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e
https://docs.microsoft.com/en-us/dotnet/csharp/versioning

## Thoughts without structure

When everyone agrees on the meaning of version numbers, it makes software development easier for everyone.

Teams who use semantic versioning seem to lose little and gain a lot.

